int init_philo(t_philo *philo, t_args *args, int id, t_mutex *other_fork)
{
	initialize right fork;
	left fork = NULL;



}

//start lifetime
int birth_philos(t_philo all_philos, first philo, args)
{
	pthread_t thread[args.philo_count];
	t_philo next_philo;
	t_philo *cur_philo;
	
	//t_thread cur_thread;

	int idx;
	idx = 0;
	cur_philo = first_philo;
	while(idx < args.philo_count)
	{
		if (idx + 1 == args.philo_count)
			cur_philo.left_fork = all_philos[0].right_fork;
		else
		{

		init_philo(&next_philo, id = idx + 1);
		cur_philo.left_fork = next_philo.right_fork;
		all_philos[cur_philo.id] = cur_philo;
		pthread_create(thread + idx, cur_philo, &routine);
		cur_philo = next_philo;
		}
		pthread join cur thread;
		idx++;
	}



}



int pickup_fork(t_philo *philo)
{
	

}




static int thus_god_created_man(t_data *args, t_philo all_philos[])
{
	pthread_t *philo_th;
	// t_philo next_philo;
	// t_philo cur_philo;
	int idx;

	philo_th = malloc(sizeof(pthread_t) * args->philo_count);
	// next_philo = malloc(sizeof(t_philo) * args->philo_count);
	if (philo_th == NULL)
		return (EXIT_FAILURE);	
	init_philo(&all_philos[0], args, 0, NULL);
	// all_philos[0] = cur_philo;
	idx = -1;
	while (++idx < args->philo_count)
	{
		if ((idx + 1) == args->philo_count)
			init_philo(all_philos + idx + 1, args, idx + 1, all_philos[0].right_fork);
		else
		{
			init_philo((all_philos + idx + 1), args, idx + 1, NULL);
			all_philos[idx].left_fork = all_philos[idx + 1].right_fork;
			printf("id = %i, left mutex = %p\n", all_philos[idx].id, all_philos[idx].left_fork);
		}
		pthread_create(philo_th + idx, NULL, daily_routine, all_philos + idx);
	}
	return (EXIT_SUCCESS);
}